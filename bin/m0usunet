#!/usr/bin/env python3
"""M0usuNet - Mesh network hub TUI"""
import curses
import subprocess
import threading
import time

PI = "pi5"
PI_HOME = "/home/jackpi5"

def ssh(cmd, timeout=10):
    try:
        r = subprocess.run(
            ["ssh", "-o", "ConnectTimeout=5", "-o", "BatchMode=yes", PI, cmd],
            capture_output=True, text=True, timeout=timeout
        )
        return r.stdout.strip()
    except:
        return ""

# ── Background data store ──

class Store:
    def __init__(self):
        self.lock = threading.Lock()
        self.home = {"ipad": None, "mac": None, "pixel": None,
                     "ipad_wd": "", "pixel_wd": "", "mpv": "off",
                     "lastmsg": "", "uptime": "", "loading": True}
        self.mpv = "off"
        self.msg_history = []
        self._home_thread = None
        self._mpv_thread = None

    def refresh_home(self):
        if self._home_thread and self._home_thread.is_alive():
            return
        self._home_thread = threading.Thread(target=self._do_home, daemon=True)
        self._home_thread.start()

    def refresh_mpv(self):
        if self._mpv_thread and self._mpv_thread.is_alive():
            return
        self._mpv_thread = threading.Thread(target=self._do_mpv, daemon=True)
        self._mpv_thread.start()

    def refresh_messages(self):
        threading.Thread(target=self._do_messages, daemon=True).start()

    def _do_home(self):
        results = {}
        threads = []
        def check(key, cmd):
            results[key] = ssh(cmd)
        checks = [
            ("ipad", 'ssh -o ConnectTimeout=3 -o BatchMode=yes ipad "echo ok"'),
            ("mac", 'ssh -o ConnectTimeout=3 -o BatchMode=yes mac "echo ok"'),
            ("pixel", 'adb devices 2>/dev/null | grep -q device$ && echo ok'),
            ("ipad_wd", "systemctl is-active ipad-watchdog 2>/dev/null"),
            ("pixel_wd", "systemctl is-active pixel-watchdog 2>/dev/null"),
            ("uptime", "uptime -p 2>/dev/null"),
            ("lastmsg", "tail -1 ~/messages.log 2>/dev/null"),
        ]
        for key, cmd in checks:
            t = threading.Thread(target=check, args=(key, cmd), daemon=True)
            threads.append(t)
            t.start()
        for t in threads:
            t.join(timeout=10)
        mpv = self._get_mpv()
        with self.lock:
            self.home = {
                "ipad": results.get("ipad") == "ok",
                "mac": results.get("mac") == "ok",
                "pixel": results.get("pixel") == "ok",
                "ipad_wd": results.get("ipad_wd", ""),
                "pixel_wd": results.get("pixel_wd", ""),
                "uptime": results.get("uptime", ""),
                "lastmsg": results.get("lastmsg", ""),
                "mpv": mpv,
                "loading": False,
            }

    def _get_mpv(self):
        return ssh("""
            if [ -S /tmp/mpv-socket ]; then
                title=$(echo '{"command": ["get_property", "media-title"]}' | socat - /tmp/mpv-socket 2>/dev/null | grep -o '"data":"[^"]*"' | cut -d'"' -f4)
                pos=$(echo '{"command": ["get_property", "time-pos"]}' | socat - /tmp/mpv-socket 2>/dev/null | grep -o '"data":[0-9.]*' | cut -d: -f2)
                dur=$(echo '{"command": ["get_property", "duration"]}' | socat - /tmp/mpv-socket 2>/dev/null | grep -o '"data":[0-9.]*' | cut -d: -f2)
                paused=$(echo '{"command": ["get_property", "pause"]}' | socat - /tmp/mpv-socket 2>/dev/null | grep -o '"data":[a-z]*' | cut -d: -f2)
                vol=$(echo '{"command": ["get_property", "volume"]}' | socat - /tmp/mpv-socket 2>/dev/null | grep -o '"data":[0-9.]*' | cut -d: -f2)
                if [ -n "$title" ]; then
                    state="playing"
                    [ "$paused" = "true" ] && state="paused"
                    echo "$state|$title|$pos|$dur|$vol"
                else echo "off"; fi
            else echo "off"; fi
        """)

    def _do_mpv(self):
        result = self._get_mpv()
        with self.lock:
            self.mpv = result

    def _do_messages(self):
        raw = ssh("tail -5 ~/messages.log 2>/dev/null")
        with self.lock:
            if raw:
                self.msg_history = raw.split("\n")

    def get_home(self):
        with self.lock:
            return dict(self.home)

    def get_mpv(self):
        with self.lock:
            return self.mpv

    def get_messages(self):
        with self.lock:
            return list(self.msg_history)

# ── Drawing ──

def safe_addstr(stdscr, y, x, s, *args):
    h, w = stdscr.getmaxyx()
    if 0 <= y < h and 0 <= x < w:
        stdscr.addnstr(y, x, s, max(0, w - x - 1), *args)

def draw_tabs(stdscr, active, w):
    tabs = ["HOME", "MESSAGING", "TV"]
    stdscr.attron(curses.color_pair(5))
    safe_addstr(stdscr, 0, 0, " " * (w - 1))
    x = 1
    for i, name in enumerate(tabs):
        if i == active:
            stdscr.attron(curses.color_pair(1) | curses.A_BOLD)
            safe_addstr(stdscr, 0, x, f" {name} ")
            stdscr.attroff(curses.color_pair(1) | curses.A_BOLD)
        else:
            stdscr.attron(curses.color_pair(5))
            safe_addstr(stdscr, 0, x, f" {name} ")
        x += len(name) + 3
    stdscr.attroff(curses.color_pair(5))

def draw_box(stdscr, y, x, h, w, title=""):
    safe_addstr(stdscr, y, x, "┌" + "─" * (w - 2) + "┐")
    for i in range(1, h - 1):
        safe_addstr(stdscr, y + i, x, "│" + " " * (w - 2) + "│")
    safe_addstr(stdscr, y + h - 1, x, "└" + "─" * (w - 2) + "┘")
    if title:
        stdscr.attron(curses.A_BOLD)
        safe_addstr(stdscr, y, x + 2, f" {title} ")
        stdscr.attroff(curses.A_BOLD)

def dot(stdscr, y, x, is_up):
    pair = 2 if is_up else 3
    stdscr.attron(curses.color_pair(pair))
    safe_addstr(stdscr, y, x, "●")
    stdscr.attroff(curses.color_pair(pair))

def draw_mpv_block(stdscr, y, mpv_str, w, title="NOW PLAYING"):
    bw = min(w - 2, 58)
    draw_box(stdscr, y, 1, 4, bw, title)
    if mpv_str and mpv_str != "off" and "|" in mpv_str:
        parts = mpv_str.split("|")
        state, title_s = parts[0], parts[1][:45] if len(parts) > 1 else ""
        icon = "▶" if state == "playing" else "⏸"
        safe_addstr(stdscr, y + 1, 3, f"{icon} {title_s}", curses.color_pair(2))
        if len(parts) >= 4:
            try:
                pos, dur = float(parts[2]), float(parts[3])
                pm = f"{int(pos)//60}:{int(pos)%60:02d}"
                dm = f"{int(dur)//60}:{int(dur)%60:02d}"
                info = f"  {pm} / {dm}"
                if len(parts) > 4:
                    info += f"  vol:{parts[4]}"
                safe_addstr(stdscr, y + 2, 3, info)
            except:
                pass
    else:
        stdscr.attron(curses.A_DIM)
        safe_addstr(stdscr, y + 1, 3, "Nothing playing")
        stdscr.attroff(curses.A_DIM)

def draw_home(stdscr, data, w):
    y = 2
    stdscr.attron(curses.color_pair(4) | curses.A_BOLD)
    safe_addstr(stdscr, y, 2, "M 0 u s u N e t")
    stdscr.attroff(curses.color_pair(4) | curses.A_BOLD)
    if data.get("loading"):
        safe_addstr(stdscr, y, 22, "(refreshing...)", curses.A_DIM)
    y += 2

    bw = min(w - 2, 58)
    draw_box(stdscr, y, 1, 7, bw, "DEVICES")
    stdscr.attron(curses.A_BOLD)
    safe_addstr(stdscr, y + 1, 3, f"{'Device':<10}{'Address':<16}{'Status':<10}{'Role':<10}")
    stdscr.attroff(curses.A_BOLD)
    devices = [
        ("Pi",    "192.168.0.19",  True,              "hub"),
        ("iPad",  "192.168.0.11",  data.get("ipad"),  "iMessage"),
        ("Pixel", "USB/ADB",       data.get("pixel"), "apps"),
        ("Mac",   "100.82.246.99", data.get("mac"),   "SMS relay"),
    ]
    for i, (name, addr, up_st, role) in enumerate(devices):
        row = y + 2 + i
        safe_addstr(stdscr, row, 3, f"{name:<10}{addr:<16}")
        dot(stdscr, row, 29, up_st)
        safe_addstr(stdscr, row, 31, f"{'up' if up_st else 'down':<8}{role}")
    y += 8

    draw_box(stdscr, y, 1, 5, min(bw, 42), "SERVICES")
    for i, (name, val) in enumerate([
        ("iPad watchdog",  data.get("ipad_wd") == "active"),
        ("Pixel watchdog", data.get("pixel_wd") == "active"),
    ]):
        row = y + 1 + i
        safe_addstr(stdscr, row, 3, f"{name:<20}")
        dot(stdscr, row, 23, val)
        safe_addstr(stdscr, row, 25, "running" if val else "stopped")
    y += 6

    draw_mpv_block(stdscr, y, data.get("mpv", "off"), w)
    y += 5

    draw_box(stdscr, y, 1, 3, bw, "LAST MESSAGE")
    msg = data.get("lastmsg", "")
    if msg:
        safe_addstr(stdscr, y + 1, 3, msg[:bw - 4])
    else:
        stdscr.attron(curses.A_DIM)
        safe_addstr(stdscr, y + 1, 3, "No messages")
        stdscr.attroff(curses.A_DIM)
    y += 4

    stdscr.attron(curses.A_DIM)
    safe_addstr(stdscr, y, 2, f"Pi {data.get('uptime', '')}")
    stdscr.attroff(curses.A_DIM)

def draw_messaging(stdscr, msg_input, msg_status, msg_history, w):
    y = 2
    stdscr.attron(curses.color_pair(4) | curses.A_BOLD)
    safe_addstr(stdscr, y, 2, "MESSAGING")
    stdscr.attroff(curses.color_pair(4) | curses.A_BOLD)
    y += 2

    bw = min(w - 2, 58)
    draw_box(stdscr, y, 1, 5, bw, "SEND")
    safe_addstr(stdscr, y + 1, 3, "To:  ", curses.A_BOLD)
    safe_addstr(stdscr, y + 2, 3, "Msg: ", curses.A_BOLD)
    if msg_input["field"] == "to":
        safe_addstr(stdscr, y + 1, 8, msg_input["to"] + "█")
        safe_addstr(stdscr, y + 2, 8, msg_input["msg"])
    else:
        safe_addstr(stdscr, y + 1, 8, msg_input["to"])
        safe_addstr(stdscr, y + 2, 8, msg_input["msg"] + "█")
    if msg_status:
        safe_addstr(stdscr, y + 3, 3, msg_status[:bw - 4], curses.color_pair(2))
    y += 6

    rh = min(12, curses.LINES - y - 3)
    draw_box(stdscr, y, 1, rh, bw, "RECENT")
    for i, line in enumerate(msg_history[-(rh - 2):]):
        safe_addstr(stdscr, y + 1 + i, 3, line[:bw - 4])
    y += rh + 1

    stdscr.attron(curses.A_DIM)
    safe_addstr(stdscr, curses.LINES - 2, 2, "Enter=next field/send  Esc=clear  Tab=switch tab")
    stdscr.attroff(curses.A_DIM)

def draw_tv(stdscr, tv_input, tv_status, mpv_info, w):
    y = 2
    stdscr.attron(curses.color_pair(4) | curses.A_BOLD)
    safe_addstr(stdscr, y, 2, "TV")
    stdscr.attroff(curses.color_pair(4) | curses.A_BOLD)
    y += 2

    bw = min(w - 2, 58)
    draw_box(stdscr, y, 1, 3, bw, "PLAY URL")
    safe_addstr(stdscr, y + 1, 3, tv_input + "█")
    y += 4

    draw_mpv_block(stdscr, y, mpv_info, w)
    y += 5

    if tv_status:
        safe_addstr(stdscr, y, 3, tv_status[:52], curses.color_pair(2))
        y += 2

    draw_box(stdscr, y, 1, 7, min(bw, 42), "CONTROLS")
    for i, c in enumerate([
        "Space  = pause/resume",
        "s      = stop",
        "← / →  = seek -10s / +10s",
        "+ / -  = volume up/down",
        "Enter  = play URL above",
    ]):
        safe_addstr(stdscr, y + 1 + i, 3, c)

# ── Main ──

def main(stdscr):
    curses.curs_set(0)
    curses.start_color()
    curses.use_default_colors()
    curses.init_pair(1, curses.COLOR_BLACK, curses.COLOR_CYAN)
    curses.init_pair(2, curses.COLOR_GREEN, -1)
    curses.init_pair(3, curses.COLOR_RED, -1)
    curses.init_pair(4, curses.COLOR_CYAN, -1)
    curses.init_pair(5, curses.COLOR_WHITE, curses.COLOR_BLACK)

    stdscr.timeout(200)
    stdscr.keypad(True)

    store = Store()
    tab = 0
    last_home_kick = 0
    last_mpv_kick = 0

    msg_input = {"to": "", "msg": "", "field": "to"}
    msg_status = ""
    tv_input = ""
    tv_status = ""

    # Kick off initial fetches (non-blocking)
    store.refresh_home()
    store.refresh_messages()

    while True:
        h, w = stdscr.getmaxyx()
        stdscr.clear()

        now = time.time()

        # Background refresh kicks
        if tab == 0 and now - last_home_kick > 10:
            store.refresh_home()
            last_home_kick = now
        if tab == 2 and now - last_mpv_kick > 3:
            store.refresh_mpv()
            last_mpv_kick = now

        # Draw
        draw_tabs(stdscr, tab, w)

        if tab == 0:
            draw_home(stdscr, store.get_home(), w)
        elif tab == 1:
            draw_messaging(stdscr, msg_input, msg_status, store.get_messages(), w)
        elif tab == 2:
            draw_tv(stdscr, tv_input, tv_status, store.get_mpv(), w)

        stdscr.attron(curses.A_DIM)
        safe_addstr(stdscr, h - 1, 1, " Tab=next tab  q=quit (from HOME) ")
        stdscr.attroff(curses.A_DIM)

        stdscr.refresh()

        try:
            ch = stdscr.getch()
        except:
            continue

        if ch == -1:
            continue

        # Global: Tab cycles tabs, q quits from HOME
        if ch == 9:  # Tab = next tab
            tab = (tab + 1) % 3
            if tab == 0:
                store.refresh_home()
                last_home_kick = now
            elif tab == 1:
                store.refresh_messages()
            elif tab == 2:
                store.refresh_mpv()
                last_mpv_kick = now
            continue

        if tab == 0:
            if ch == ord('q'):
                break

        # MESSAGING input
        elif tab == 1:
            if ch == 27:  # Esc = clear
                msg_input = {"to": "", "msg": "", "field": "to"}
                msg_status = ""
            elif ch in (curses.KEY_BACKSPACE, 127, 8):
                f = msg_input["field"]
                msg_input[f] = msg_input[f][:-1]
            elif ch == 10:  # Enter
                if msg_input["to"] and msg_input["msg"]:
                    msg_status = "Sending..."
                    stdscr.refresh()
                    def send():
                        nonlocal msg_status
                        result = ssh(f'{PI_HOME}/relay.sh {msg_input["to"]} {msg_input["msg"]}', timeout=15)
                        msg_status = result if result else "Sent"
                        store.refresh_messages()
                    threading.Thread(target=send, daemon=True).start()
                    msg_input["msg"] = ""
                elif msg_input["field"] == "to" and msg_input["to"]:
                    msg_input["field"] = "msg"
            elif 32 <= ch <= 126:
                msg_input[msg_input["field"]] += chr(ch)

        # TV input
        elif tab == 2:
            if ch == ord(' '):
                threading.Thread(target=lambda: ssh(f"{PI_HOME}/yt.sh pause"), daemon=True).start()
                time.sleep(0.3)
                store.refresh_mpv()
            elif ch == ord('s'):
                threading.Thread(target=lambda: ssh(f"{PI_HOME}/yt.sh stop"), daemon=True).start()
                tv_status = "Stopped"
            elif ch == curses.KEY_RIGHT:
                threading.Thread(target=lambda: ssh(f"{PI_HOME}/yt.sh seek 10"), daemon=True).start()
            elif ch == curses.KEY_LEFT:
                threading.Thread(target=lambda: ssh(f"{PI_HOME}/yt.sh seek -10"), daemon=True).start()
            elif ch == ord('+') or ch == ord('='):
                threading.Thread(target=lambda: ssh(f"{PI_HOME}/yt.sh vol 80"), daemon=True).start()
                store.refresh_mpv()
            elif ch == ord('-'):
                threading.Thread(target=lambda: ssh(f"{PI_HOME}/yt.sh vol 40"), daemon=True).start()
                store.refresh_mpv()
            elif ch == 10:  # Enter = play URL
                if tv_input:
                    url = tv_input
                    tv_input = ""
                    tv_status = "Loading..."
                    def play():
                        nonlocal tv_status
                        result = ssh(f"{PI_HOME}/yt.sh '{url}'", timeout=20)
                        tv_status = result if result else "Playing"
                        time.sleep(2)
                        store.refresh_mpv()
                    threading.Thread(target=play, daemon=True).start()
            elif ch in (curses.KEY_BACKSPACE, 127, 8):
                tv_input = tv_input[:-1]
            elif ch == 27:  # Esc
                tv_input = ""
                tv_status = ""
            elif 32 <= ch <= 126:
                tv_input += chr(ch)

curses.wrapper(main)
